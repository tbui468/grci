module Not(a) -> out {
    Nand(a, a) -> out 
}

module Not2(a[2]) -> b[2] {
    Not(a[0]) -> b[0]
    Not(a[1]) -> b[1]
}

module ConstZero() -> a {
    Not(0) -> a        
}
module ConstOne() -> a {
    Not(1) -> a        
}
module ConstZeroInfer() -> a[2] {
    Not2(0) -> a        
}
module ConstOneInfer() -> a[2] {
    Not2(1) -> a        
}
module ConstWire() -> out[2] {
    1 -> a
    0 -> b
    Not(a) -> out[0]
    Not(b) -> out[1]
}

module ConstWireInfer() -> b[2] {
    {1, 0} -> a
    Not2(a) -> b
}
module ConstMixed(a) -> b[2] {
    {a, 1} -> c
    Not2(c) -> b
}

module Nand2(a[2], b[2]) -> c[2] {
    Nand(a[0], b[0]) -> c[0]
    Nand(a[1], b[1]) -> c[1]
}

module Nand4(a[4], b[4]) -> c[4] {
    Nand(a[0], b[0]) -> c[0]
    Nand(a[1], b[1]) -> c[1]
    Nand(a[2], b[2]) -> c[2]
    Nand(a[3], b[3]) -> c[3]
}

module Nand8(a[8], b[8]) -> c[8] {
    Nand(a[0], b[0]) -> c[0]
    Nand(a[1], b[1]) -> c[1]
    Nand(a[2], b[2]) -> c[2]
    Nand(a[3], b[3]) -> c[3]
    Nand(a[4], b[4]) -> c[4]
    Nand(a[5], b[5]) -> c[5]
    Nand(a[6], b[6]) -> c[6]
    Nand(a[7], b[7]) -> c[7]
}

module Test1(a, b) -> c {
    Nand(a, b) -> d
    d -> e
    e -> c
}
module Test2(a, b) -> c {
    Nand(a, b) -> d
    Not(e) -> c
    d -> e
}
module Test3(a, b, c[2]) -> d[2] {
    Nand(b, c[1]) -> e
    Nand(a, c[0]) -> f
    {f, e} -> g
    g -> d
}
module Test4(a, b[2], c) -> d[2] {
    Nand(a, b[1]) -> e
    Nand(b[0], c) -> d[1]
    e -> d[0]
}

module Nand2Infer(a[2], b[2]) -> e[2] {
    Nand2(a, b) -> e
}

module Slice1(in[4]) -> out[2] {
    Nand2Infer(in[0..1], in[2..3]) -> out
}

module Slice2(in[4]) -> out[2] {
    Nand2Infer(in[0..1], in[2..3]) -> d
    d -> out[0..1]
}

//slicing outputs
module Slice3(in[4]) -> out[2] {
    Nand2Infer(in[0..1], in[2..3]) -> d
    {d[0], d[1]} -> out
}
//slicing inputs
module Slice4(in[4]) -> out[2] {
    {in[0], in[1]} -> a
    {in[2], in[3]} -> b
    Nand2Infer(a, b) -> out
}
module Slice5(a[2], b[2]) -> c, d {
    Nand2(a, b) -> temp
    temp[1..1] -> c
    temp[0..0] -> d
}

module Slice6(a[8], b[8]) -> a, b, c, d {
    Nand8(a, b) -> temp
    temp[0..4] -> t
    t[0] -> a
    t[1] -> b
    t[2] -> c
    t[3] -> d
}

module Not4(a[4]) -> c[4] {
    Not(a[0]) -> c[0]
    Not(a[1]) -> c[1]
    Not(a[2]) -> c[2]
    Not(a[3]) -> c[3]
}

module Slice7(a[4], b[4]) -> x[2], y[2] {
    /*
    //This actually passes test
    Nand4(a, b) -> temp
    Not4(temp) -> temp2
    temp2[0..1] -> x
    temp2[2..3] -> y
    */

    Nand4(a, b) -> temp
    temp[0..1] -> c
    temp[2..3] -> d

    Not2(c) -> x
    Not2(d) -> y
}


module And(a, b) -> out {
    Nand(a, b) -> temp
    Not(temp) -> out
}

module Or(a, b) -> out {
    Not(a) -> nA
    Not(b) -> nB
    And(nB, nA) -> temp1
    Not(temp1) -> out
}

module Or4Way(in[4]) -> out {
    Or(in[0], in[1]) -> a
    Or(a, in[2]) -> b
    Or(b, in[3]) -> out
}

module Not8(a[8]) -> out[8] {
    Not(a[0]) -> out[0]
    Not(a[1]) -> out[1]
    Not(a[2]) -> out[2]
    Not(a[3]) -> out[3]
    Not(a[4]) -> out[4]
    Not(a[5]) -> out[5]
    Not(a[6]) -> out[6]
    Not(a[7]) -> out[7]
}

module Slice8(a[8]) -> zr, ng {
    Not8(a) -> t1
    Not8(t1) -> temp
    temp[0..3] -> first
    temp[4..7] -> second
    Or4Way(first) -> zr
    Or4Way(second) -> ng
/*
    Not16(a) -> t1
    Not16(t1) -> temp
    temp[0..7] -> first
    temp[8..15] -> second
    Or8Way(first) -> zr
    Or8Way(second) -> ng
*/
}

module Nor(a, b) -> out {
    Or(a, b) -> temp
    Not(temp) -> out
}

module Xor(a, b) -> out {
    Not(a) -> nA
    Not(b) -> nB
    And(a, nB) -> and1
    And(nA, b) -> and2
    Or(and1, and2) -> out
}

module Xnor(a, b) -> out {
    Xor(a, b) -> temp
    Not(temp) -> out
}

module Mux(a, b, sel) -> out {
    Not(sel) -> notSel
    And(b, sel) -> and1
    And(a, notSel) -> and2
    Or(and1, and2) -> out
}

module DMux(in, sel) -> a, b {
    Not(sel) -> notSel
    And(in, notSel) -> a
    And(in, sel) -> b
}

module DMux4Way(in, sel[2]) -> a, b, c, d {
    DMux(in, sel[1]) -> ao, bo
    DMux(ao, sel[0]) -> a, b
    DMux(bo, sel[0]) -> c, d
}
module DMux4WayMixed(in, sel[2]) -> a, b, c, d {
    DMux(bo, sel[0]) -> c, d
    DMux(ao, sel[0]) -> a, b
    DMux(in, sel[1]) -> ao, bo
}

module DMux4WayInfer0(in, sel[2]) -> a, b[2], c {
    DMux(in, sel[1]) -> ao, bo
    DMux(ao, sel[0]) -> a, b[0]
    DMux(bo, sel[0]) -> b[1], c
}

module DMux4WayInfer1(in, sel[2]) -> out[4] {
    DMux(in, sel[1]) -> ao, bo
    DMux(ao, sel[0]) -> out[0], out[1]
    DMux(bo, sel[0]) -> out[2], out[3]
}

/*
module DFF(d) -> q, nQ {
    Not(d) -> nD
    Nand(d, clock) -> tl
    Nand(nD, clock) -> bl
    Nand(tl, br) -> tr
    Nand(bl, tr) -> br
    tr -> q
    br -> nQ
}
*/

module Bit(in, load) -> out {
    Mux(dffOut, in, load) -> muxOut
    Dff(muxOut) -> dffOut
    dffOut -> out
}

/*
    Program Counter bug
*/

module Mux16(a[16], b[16], sel) -> out[16] {
    Mux(a[0], b[0], sel) -> out[0]
    Mux(a[1], b[1], sel) -> out[1]
    Mux(a[2], b[2], sel) -> out[2]
    Mux(a[3], b[3], sel) -> out[3]
    Mux(a[4], b[4], sel) -> out[4]
    Mux(a[5], b[5], sel) -> out[5]
    Mux(a[6], b[6], sel) -> out[6]
    Mux(a[7], b[7], sel) -> out[7]
    Mux(a[8], b[8], sel) -> out[8]
    Mux(a[9], b[9], sel) -> out[9]
    Mux(a[10], b[10], sel) -> out[10]
    Mux(a[11], b[11], sel) -> out[11]
    Mux(a[12], b[12], sel) -> out[12]
    Mux(a[13], b[13], sel) -> out[13]
    Mux(a[14], b[14], sel) -> out[14]
    Mux(a[15], b[15], sel) -> out[15]
}

module Mux4Way16(a[16], b[16], c[16], d[16], sel[2]) -> out[16] {
    Mux16(a, b, sel[0]) -> out1
    Mux16(c, d, sel[0]) -> out2
    Mux16(out1, out2, sel[1]) -> out
}

module PCBug(in[16], reset, load, inc) -> out[16] {
    And(reset, load) -> in1 

    {in1, inc} -> sel

    Mux4Way16(0, in, 0, 0, sel) -> out
}


module OutputArrays(a[8]) -> c[2], d[2], e[2], f[2] {
    Not2(a[0..1]) -> c
    Not2(a[2..3]) -> d
    Not2(a[4..5]) -> e
    Not2(a[6..7]) -> f
}

module SliceOutputArrays(a[8]) -> out[8] {
    OutputArrays(a) -> x, y, z, w
    y[0] -> out[0]
    z[1] -> out[1]
    x[0] -> out[2]
    x[1] -> out[3]
    y[1] -> out[4]
    z[0] -> out[5]
    w[0] -> out[6]
    w[1] -> out[7]
}

module ConstantOutput() -> out[2] {
    1 -> out[0]
    0 -> out[1] 
}
module NestedWireConst(in) -> out {
    Or4Way({1, 0, 0, 1}) -> out 
}
module NestedWireIdentifer(in) -> out {
    Or4Way({in, 0, in, 0}) -> out 
}

module NestedWireSlice(in[4]) -> out {
    Or4Way({0, in[3..3], 0, in[0]}) -> out 
}

//TODO: should rename this since it's not related to nesting wires
module NestedWireComplex() -> x, y, z, w {
    { 0, 1 } -> w0
    { 0, 0 } -> w1
    w0[0] -> x
    w0[1] -> y
    w1[0] -> z
    w1[1] -> w
}

module OffsetBug() -> x, y  {
    1 -> a
    0 -> b
    { 0, a, 0, 0} -> w0
    { 0, b, 0, 0} -> w1
    w0[1] -> x
    w1[1] -> y
}

module Gate() -> a, b {
    1 -> a
    0 -> b
}
module OffsetBug2() -> x, y  {
    Gate() -> a, b
    { 0, a, 0, 0} -> w0
    { 0, b, 0, 0} -> w1
    w0[1] -> x
    w1[1] -> y
}

module OffsetBug3() -> x, y {
    Gate() -> a, b
    { 0, a, 0, 0} -> w0
    { 0, b, 0, 0} -> w1
    Or4Way (w0) -> x
    Or4Way (w1) -> y
}


module CycleBugInner(x[8]) -> out[4] {
    x[4..7] -> out
}
module CycleBug() -> x[4] {
    {0, 0, 0, 0, 1, 1, 1, 1} -> y
    CycleBugInner(y) -> x
}
