/*
    Basic logic gates
*/
module Not(a) -> out {
    Nand(a, a) -> out 
}

module And(a, b) -> out {
    Nand(a, b) -> temp
    Not(temp) -> out
}

module And4Way(a, b, c, d) -> out {
    And(a, b) -> a1
    And(c, d) -> a2
    And(a1, a2) -> out
}

module Or(a, b) -> out {
    Not(a) -> nA
    Not(b) -> nB
    And(nB, nA) -> temp1
    Not(temp1) -> out
}

module Or4Way(i0, i1, i2, i3) -> out {
    Or(i0, i1) -> a
    Or(a, i2) -> b
    Or(b, i3) -> out
}
module Or8Way(in[8]) -> out {
    Or(in[0], in[1]) -> a
    Or(a, in[2]) -> b
    Or(b, in[3]) -> c
    Or(c, in[4]) -> d
    Or(d, in[5]) -> e
    Or(e, in[6]) -> f
    Or(f, in[7]) -> out
}

module Xor(a, b) -> out {
    Not(a) -> nA
    Not(b) -> nB
    And(a, nB) -> and1
    And(nA, b) -> and2
    Or(and1, and2) -> out
}

module Xor8(a[8], b[8]) -> out[8] {
    Xor(a[0], b[0]) -> out[0]
    Xor(a[1], b[1]) -> out[1]
    Xor(a[2], b[2]) -> out[2]
    Xor(a[3], b[3]) -> out[3]
    Xor(a[4], b[4]) -> out[4]
    Xor(a[5], b[5]) -> out[5]
    Xor(a[6], b[6]) -> out[6]
    Xor(a[7], b[7]) -> out[7]
}


/*
    Mux and DMux
*/

module Mux(a, b, sel) -> out {
    Not(sel) -> notSel
    And(b, sel) -> and1
    And(a, notSel) -> and2
    Or(and1, and2) -> out
}

module Mux8(a[8], b[8], sel) -> out[8] {
    Mux(a[0], b[0], sel) -> out[0]
    Mux(a[1], b[1], sel) -> out[1]
    Mux(a[2], b[2], sel) -> out[2]
    Mux(a[3], b[3], sel) -> out[3]
    Mux(a[4], b[4], sel) -> out[4]
    Mux(a[5], b[5], sel) -> out[5]
    Mux(a[6], b[6], sel) -> out[6]
    Mux(a[7], b[7], sel) -> out[7]
}

module Mux4Way8(a[8], b[8], c[8], d[8], sel[2]) -> out[8] {
    Mux8(a, b, sel[0]) -> out1
    Mux8(c, d, sel[0]) -> out2
    Mux8(out1, out2, sel[1]) -> out
}

module Mux8Way8(a[8], b[8], c[8], d[8], 
                 e[8], f[8], g[8], h[8],
                 sel[3]) -> out[8] {
    Mux4Way8(a, b, c, d, sel[0..1]) -> out1
    Mux4Way8(e, f, g, h, sel[0..1]) -> out2
    Mux8(out1, out2, sel[2]) -> out
}

module DMux(in, sel) -> a, b {
    Not(sel) -> notSel
    And(in, notSel) -> a
    And(in, sel) -> b
}

module DMux4Way(in, sel[2]) -> a, b, c, d {
    DMux(in, sel[0]) -> t1, t2
    DMux(t1, sel[1]) -> a, c
    DMux(t2, sel[1]) -> b, d
}

/*
    ALU
*/

module HalfAdder(a, b) -> sum, carry {
    Xor(a, b) -> sum
    And(a, b) -> carry
}

module FullAdder(a, b, c) -> sum, carry {
    HalfAdder(a, b) -> sum1, carry1
    HalfAdder(sum1, c) -> sum, carry2
    Or(carry1, carry2) -> carry
}

module Add8(a[8], b[8]) -> out[8], carry {
    HalfAdder(a[0], b[0]) -> out[0], carry0 
    FullAdder(a[1], b[1], carry0) -> out[1], carry1
    FullAdder(a[2], b[2], carry1) -> out[2], carry2
    FullAdder(a[3], b[3], carry2) -> out[3], carry3

    FullAdder(a[4], b[4], carry3) -> out[4], carry4
    FullAdder(a[5], b[5], carry4) -> out[5], carry5
    FullAdder(a[6], b[6], carry5) -> out[6], carry6
    FullAdder(a[7], b[7], carry6) -> out[7], carry
}

module Inc8(a[8], inc) -> out[8] {
    {1, 0, 0, 0, 0, 0, 0, 0}  -> b
    Mux8(0, b, inc) -> mux
    Add8(a, mux) -> out, carry
}

module ALU(x[8], y[8], ny) -> out[8], carry, zero {
    Xor8(y, 1) -> flipped
    Inc8(flipped, 1) -> negY
    Mux8(y, negY, ny) -> finaly

    Add8(x, finaly) -> result, carry
    result -> out
    Or8Way(result) -> or
    Not(or) -> zero
}

/*
    Memory
*/

module Bit(in, load) -> out {
    Mux(dffOut, in, load) -> muxOut
    Dff(muxOut) -> dffOut
    dffOut -> out
}

module Register(in[8], load) -> out[8] {
    Bit(in[0], load) -> out[0]
    Bit(in[1], load) -> out[1]
    Bit(in[2], load) -> out[2]
    Bit(in[3], load) -> out[3]
    Bit(in[4], load) -> out[4]
    Bit(in[5], load) -> out[5]
    Bit(in[6], load) -> out[6]
    Bit(in[7], load) -> out[7]
}

module RAM4(data[8], load, addr[2]) -> out[8] {
    DMux4Way(load, addr) -> loadA, loadB, loadC, loadD
    Register(data, loadA) -> aout
    Register(data, loadB) -> bout
    Register(data, loadC) -> cout
    Register(data, loadD) -> dout
    Mux4Way8(aout, bout, cout, dout, addr) -> out
}

module RAM16(data[8], load, addr[4]) -> out[8] {
    DMux4Way(load, addr[2..3]) -> loadA, loadB, loadC, loadD
    RAM4(data, loadA, addr[0..1]) -> aout
    RAM4(data, loadB, addr[0..1]) -> bout
    RAM4(data, loadC, addr[0..1]) -> cout
    RAM4(data, loadD, addr[0..1]) -> dout
    Mux4Way8(aout, bout, cout, dout, addr[2..3]) -> out
}

/*
    CPU
*/

module PC(reset, inc) -> out[8] {
    Inc8(reg, inc) -> incout
    Mux8(incout, 0, reset) -> mux
    Register(mux, 1) -> reg
    reg -> out
}

module ShiftRegister(reset) -> out[6] {
    Bit(o5, 1) -> b0
    b0 -> out[0]

    Bit(o0, 1) -> b1
    b1 -> out[1]

    Bit(o1, 1) -> b2
    b2 -> out[2]

    Bit(o2, 1) -> b3
    b3 -> out[3]

    Bit(o3, 1) -> b4
    b4 -> out[4]

    Bit(o4, 1) -> b5
    b5 -> out[5]

    Mux(b0, 0, reset) -> o0
    Mux(b1, 0, reset) -> o1
    Mux(b2, 0, reset) -> o2
    Mux(b3, 0, reset) -> o3
    Mux(b4, 0, reset) -> o4
    Mux(b5, 1, reset) -> o5
}

/*
    Computer
*/

module FetchSignals(ring[6]) -> control_bits[8] {
    {0, 1, 0,   0, 0, 0,   0, 0} -> t0 //load mar and increment pc
    {0, 0, 0,   0, 1, 0,   0, 0} -> t1 //load MDR with data
    {1, 0, 0,   0, 0, 0,   0, 0} -> t2 //move MDR to CIR

    Mux8(t0, t1, ring[1]) -> temp
    Mux8(temp, t2, ring[2]) -> control_bits
}

module LDASignals(ring[6]) -> control_bits[8] {
    {0, 1, 0,   1, 0, 0,   0, 0} -> t3 //load MAR with instr operand
    {0, 0, 0,   0, 1, 0,   0, 0} -> t4 //load MDR register with RAM[MAR]
    {0, 0, 1,   0, 0, 0,   0, 0} -> t5 //load ACC with MDR

    Mux8(t3, t4, ring[4]) -> temp
    Mux8(temp, t5, ring[5]) -> control_bits
}

module ADDSignals(ring[6]) -> control_bits[8] {
    {0, 1, 0,   1, 0, 0,   0, 0} -> t3 //load mar with instr operand
    {0, 0, 0,   0, 1, 0,   0, 0} -> t4 //load B register with RAM[MAR]
    {0, 0, 1,   0, 0, 1,   0, 0} -> t5 //Add B to A, and store in A
    {0, 0, 0,   0, 0, 0,   0, 0} -> noop

    Or(ring[3], 0) -> sell
    Or(ring[4], 0) -> selh
    {sell, selh} -> sel
    Mux4Way8(t3, t4, t5, noop, sel) -> control_bits
}

module SUBSignals(ring[6]) -> control_bits[8] {
    {0, 1, 0,   1, 0, 0,   0, 0} -> t3 //load mar with instr operand
    {0, 0, 0,   0, 1, 0,   0, 0} -> t4 //load B register with RAM[MAR]
    {0, 0, 1,   0, 0, 1,   1, 0} -> t5 //Add -B to A, and store in A
    {0, 0, 0,   0, 0, 0,   0, 0} -> noop

    Or(ring[3], 0) -> sell
    Or(ring[4], 0) -> selh
    {sell, selh} -> sel
    Mux4Way8(t3, t4, t5, noop, sel) -> control_bits
}

module STASignals(ring[6]) -> control_bits[8] {
    {0, 1, 0,   1, 0, 0,   0, 0} -> t3 //load mar with instr operand
    {0, 0, 0,   0, 0, 0,   0, 1} -> t4 //write A to address stored in MAR

    Or(ring[3], 0) -> sel
    Mux8(t3, t4, sel) -> control_bits
}

module HLTSignals(ring[6]) -> control_bits[8] {
    {0, 0, 0,   0, 0, 0,   0, 0} -> control_bits
}

module Controller(instr[8], reset) -> loadInstr, loadMar, loadA, hbAddr, 
                                      halt, loadB, aGetsAluResult, negAluY, 
                                      storeA  {
    ShiftRegister(reset) -> ring

    Or4Way(ring[0], ring[1], ring[2], 0) -> isFetch
    Not(instr[1]) -> n1
    Not(isFetch) -> nFetch
    And4Way(instr[0], n1, instr[2], nFetch) -> halt

    {0, 0, 0, 0,   0, 0, 0, 0} -> noop_signals

    FetchSignals(ring) -> fetch_signals
    HLTSignals(ring) -> halt_signals
    LDASignals(ring) -> lda_signals
    ADDSignals(ring) -> add_signals
    SUBSignals(ring) -> sub_signals
    STASignals(ring) -> sta_signals

    Mux8Way8(noop_signals, lda_signals, add_signals, sub_signals, sta_signals, halt_signals, noop_signals, noop_signals, instr[0..2]) -> cs_candidates
    Mux8(cs_candidates, fetch_signals, isFetch) -> cs

    cs[0] -> loadInstr
    cs[1] -> loadMar
    cs[2] -> loadA
    cs[3] -> hbAddr

    cs[4] -> loadB
    cs[5] -> aGetsAluResult
    cs[6] -> negAluY
    cs[7] -> storeA
}

/*
    NOP 0000 XXXX
    LDA 1000 AAAA
    ADD 0100 AAAA
    SUB 1100 AAAA
    STA 0010 AAAA
    HLT 1010 XXXX
*/

module Computer(reset) -> halt {
    ram: RAM16(acc, storeA, mar[0..3]) -> out

    {cir[4..7], 0, 0, 0, 0} -> operand
    Mux8(pc, operand, hbAddr) -> marInput
    mar: Register(marInput, loadMar) -> mar
    cir: Register(mdr, loadInstr) -> cir
    Mux8(mdr, alu, aGetsAluResult) -> aInput
    acc: Register(aInput, loadA) -> acc
    mdr: Register(out, loadB) -> mdr

    pc: PC(reset, loadInstr) -> pc

    ALU(acc, mdr, negAluY) -> alu, carry, zero
    Controller(cir, reset) -> loadInstr, loadMar, loadA, hbAddr, 
                              halt, loadB, aGetsAluResult, negAluY, 
                              storeA
}

