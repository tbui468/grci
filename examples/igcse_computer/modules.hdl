/*
    Basic logic gates
*/
module Not(a) -> out {
    Nand(a, a) -> out 
}

module And(a, b) -> out {
    Nand(a, b) -> temp
    Not(temp) -> out
}

module And4Way(a, b, c, d) -> out {
    And(a, b) -> a1
    And(c, d) -> a2
    And(a1, a2) -> out
}

module Or(a, b) -> out {
    Not(a) -> nA
    Not(b) -> nB
    And(nB, nA) -> temp1
    Not(temp1) -> out
}

module Or4Way(i0, i1, i2, i3) -> out {
    Or(i0, i1) -> a
    Or(a, i2) -> b
    Or(b, i3) -> out
}
module Or8Way(in[8]) -> out {
    Or(in[0], in[1]) -> a
    Or(a, in[2]) -> b
    Or(b, in[3]) -> c
    Or(c, in[4]) -> d
    Or(d, in[5]) -> e
    Or(e, in[6]) -> f
    Or(f, in[7]) -> out
}

module Xor(a, b) -> out {
    Not(a) -> nA
    Not(b) -> nB
    And(a, nB) -> and1
    And(nA, b) -> and2
    Or(and1, and2) -> out
}

module Xor8(a[8], b[8]) -> out[8] {
    Xor(a[0], b[0]) -> out[0]
    Xor(a[1], b[1]) -> out[1]
    Xor(a[2], b[2]) -> out[2]
    Xor(a[3], b[3]) -> out[3]
    Xor(a[4], b[4]) -> out[4]
    Xor(a[5], b[5]) -> out[5]
    Xor(a[6], b[6]) -> out[6]
    Xor(a[7], b[7]) -> out[7]
}


/*
    Mux and DMux
*/

module Mux(a, b, sel) -> out {
    Not(sel) -> notSel
    And(b, sel) -> and1
    And(a, notSel) -> and2
    Or(and1, and2) -> out
}

module Mux8(a[8], b[8], sel) -> out[8] {
    Mux(a[0], b[0], sel) -> out[0]
    Mux(a[1], b[1], sel) -> out[1]
    Mux(a[2], b[2], sel) -> out[2]
    Mux(a[3], b[3], sel) -> out[3]
    Mux(a[4], b[4], sel) -> out[4]
    Mux(a[5], b[5], sel) -> out[5]
    Mux(a[6], b[6], sel) -> out[6]
    Mux(a[7], b[7], sel) -> out[7]
}

module Mux4Way8(a[8], b[8], c[8], d[8], sel[2]) -> out[8] {
    Mux8(a, b, sel[0]) -> out1
    Mux8(c, d, sel[0]) -> out2
    Mux8(out1, out2, sel[1]) -> out
}

module Mux8Way8(a[8], b[8], c[8], d[8], 
                 e[8], f[8], g[8], h[8],
                 sel[3]) -> out[8] {
    Mux4Way8(a, b, c, d, sel[0..1]) -> out1
    Mux4Way8(e, f, g, h, sel[0..1]) -> out2
    Mux8(out1, out2, sel[2]) -> out
}

module DMux(in, sel) -> a, b {
    Not(sel) -> notSel
    And(in, notSel) -> a
    And(in, sel) -> b
}

module DMux4Way(in, sel[2]) -> a, b, c, d {
    DMux(in, sel[0]) -> t1, t2
    DMux(t1, sel[1]) -> a, c
    DMux(t2, sel[1]) -> b, d
}
module DMux8Way(in, sel[3]) -> a, b, c, d, e, f, g, h {
    DMux(in, sel[0]) -> t1, t2

    DMux(t1, sel[1]) -> t3, t5
    DMux(t2, sel[1]) -> t4, t6

    DMux(t3, sel[2]) -> a, e
    DMux(t4, sel[2]) -> b, f
    DMux(t5, sel[2]) -> c, g
    DMux(t6, sel[2]) -> d, h
}

/*
    ALU
*/

module HalfAdder(a, b) -> sum, carry {
    Xor(a, b) -> sum
    And(a, b) -> carry
}

module FullAdder(a, b, c) -> sum, carry {
    HalfAdder(a, b) -> sum1, carry1
    HalfAdder(sum1, c) -> sum, carry2
    Or(carry1, carry2) -> carry
}

module Add8(a[8], b[8]) -> out[8], carry {
    HalfAdder(a[0], b[0]) -> out[0], carry0 
    FullAdder(a[1], b[1], carry0) -> out[1], carry1
    FullAdder(a[2], b[2], carry1) -> out[2], carry2
    FullAdder(a[3], b[3], carry2) -> out[3], carry3

    FullAdder(a[4], b[4], carry3) -> out[4], carry4
    FullAdder(a[5], b[5], carry4) -> out[5], carry5
    FullAdder(a[6], b[6], carry5) -> out[6], carry6
    FullAdder(a[7], b[7], carry6) -> out[7], carry
}

module Inc8(a[8], inc) -> out[8] {
    {1, 0, 0, 0, 0, 0, 0, 0}  -> b
    Mux8(0, b, inc) -> mux
    Add8(a, mux) -> out, carry
}

module ALU(x[8], y[8], ny) -> out[8], carry, zero {
    Xor8(y, 1) -> flipped
    Inc8(flipped, 1) -> negY
    Mux8(y, negY, ny) -> finaly

    Add8(x, finaly) -> result, carry
    result -> out
    Or8Way(result) -> or
    Not(or) -> zero
}

/*
    Memory
*/

module Bit(in, load) -> out {
    Mux(dffOut, in, load) -> muxOut
    Dff(muxOut) -> dffOut
    dffOut -> out
}

module Register(in[8], load) -> out[8] {
    Bit(in[0], load) -> out[0]
    Bit(in[1], load) -> out[1]
    Bit(in[2], load) -> out[2]
    Bit(in[3], load) -> out[3]
    Bit(in[4], load) -> out[4]
    Bit(in[5], load) -> out[5]
    Bit(in[6], load) -> out[6]
    Bit(in[7], load) -> out[7]
}

module RAM4(data[8], load, addr[2]) -> out[8] {
    DMux4Way(load, addr) -> loadA, loadB, loadC, loadD
    Register(data, loadA) -> aout
    Register(data, loadB) -> bout
    Register(data, loadC) -> cout
    Register(data, loadD) -> dout
    Mux4Way8(aout, bout, cout, dout, addr) -> out
}

module RAM16(data[8], load, addr[4]) -> out[8] {
    DMux4Way(load, addr[2..3]) -> loadA, loadB, loadC, loadD
    RAM4(data, loadA, addr[0..1]) -> aout
    RAM4(data, loadB, addr[0..1]) -> bout
    RAM4(data, loadC, addr[0..1]) -> cout
    RAM4(data, loadD, addr[0..1]) -> dout
    Mux4Way8(aout, bout, cout, dout, addr[2..3]) -> out
}

/*
    CPU
*/

module PC(reset, inc) -> out[8] {
    Inc8(reg, inc) -> incout
    Mux8(incout, 0, reset) -> mux
    Register(mux, 1) -> reg
    reg -> out
}

module ShiftRegister(reset) -> out[6] {
    Bit(o5, 1) -> b0
    b0 -> out[0]

    Bit(o0, 1) -> b1
    b1 -> out[1]

    Bit(o1, 1) -> b2
    b2 -> out[2]

    Bit(o2, 1) -> b3
    b3 -> out[3]

    Bit(o3, 1) -> b4
    b4 -> out[4]

    Bit(o4, 1) -> b5
    b5 -> out[5]

    Mux(b0, 0, reset) -> o0
    Mux(b1, 0, reset) -> o1
    Mux(b2, 0, reset) -> o2
    Mux(b3, 0, reset) -> o3
    Mux(b4, 0, reset) -> o4
    Mux(b5, 1, reset) -> o5
}

/*
    Computer
*/

/*

module FetchSignals(ring[6]) -> control_bits[8] {
    {0, 1, 0,   0, 0, 0,   0, 0} -> t0 //load mar and increment pc
    {0, 0, 0,   0, 1, 0,   0, 0} -> t1 //load MDR with data
    {1, 0, 0,   0, 0, 0,   0, 0} -> t2 //move MDR to CIR

    Mux8(t0, t1, ring[1]) -> temp
    Mux8(temp, t2, ring[2]) -> control_bits

}

module LDASignals(ring[6]) -> control_signals[8] {
    {0, 1, 0, 0,   0, 0, 0, 0} -> t0 //load MAR with PC, and increment PC
    {0, 0, 0, 0,   1, 0, 0, 0} -> t1 //load MDR with RAM[MAR]
    {1, 0, 0, 0,   0, 0, 0, 0} -> t2 //move MDR to CIR
    {0, 1, 0, 1,   0, 0, 0, 0} -> t3 //load MAR with LDA operand
    {0, 0, 0, 0,   1, 0, 0, 0} -> t4 //load MDR with RAM[MAR]
    {0, 0, 1, 0,   0, 0, 0, 0} -> t5 //load ACC with MDR

    Mux8(t0, t1, ring[1]) -> m0
    Mux8(m0, t2, ring[2]) -> m1
    Mux8(m1, t3, ring[3]) -> m2
    Mux8(m2, t4, ring[4]) -> m3
    Mux8(m3, t5, ring[5]) -> control_signals
}

module ADDSignals(ring[6]) -> control_bits[8] {
    {0, 1, 0,   1, 0, 0,   0, 0} -> t3 //load mar with instr operand
    {0, 0, 0,   0, 1, 0,   0, 0} -> t4 //load B register with RAM[MAR]
    {0, 0, 1,   0, 0, 1,   0, 0} -> t5 //Add B to A, and store in A
    {0, 0, 0,   0, 0, 0,   0, 0} -> noop

    Or(ring[3], 0) -> sell
    Or(ring[4], 0) -> selh
    {sell, selh} -> sel
    Mux4Way8(t3, t4, t5, noop, sel) -> control_bits
}

module SUBSignals(ring[6]) -> control_bits[8] {
    {0, 1, 0,   1, 0, 0,   0, 0} -> t3 //load mar with instr operand
    {0, 0, 0,   0, 1, 0,   0, 0} -> t4 //load B register with RAM[MAR]
    {0, 0, 1,   0, 0, 1,   1, 0} -> t5 //Add -B to A, and store in A
    {0, 0, 0,   0, 0, 0,   0, 0} -> noop

    Or(ring[3], 0) -> sell
    Or(ring[4], 0) -> selh
    {sell, selh} -> sel
    Mux4Way8(t3, t4, t5, noop, sel) -> control_bits
}

module STASignals(ring[6]) -> control_bits[8] {
    {0, 1, 0,   1, 0, 0,   0, 0} -> t3 //load mar with instr operand
    {0, 0, 0,   0, 0, 0,   0, 1} -> t4 //write ACC to MDR
    {0, 0, 0,   0, 0, 0,   0, 1} -> t4 //write MDR to RAM[MAR] //TODO

    Or(ring[3], 0) -> sel
    Mux8(t3, t4, sel) -> control_bits
}

module HLTSignals(ring[6]) -> control_bits[8] {
    {0, 0, 0,   0, 0, 0,   0, 0} -> control_bits
}

module ControlUnit(mdr[8], reset) -> loadMar, loadA, hbAddr, accToMdr, 
                                    loadB, aGetsAluResult, negAluY, storeA, 
                                    operand[8], halt  {
    ShiftRegister(reset) -> ring

    {cir[4..7], 0, 0, 0, 0} -> operand
    cir: Register(mdr, loadCir) -> cir

    Or4Way(ring[0], ring[1], ring[2], 0) -> isFetch
    Not(cir[1]) -> n1
    Not(isFetch) -> nFetch
    And4Way(cir[0], n1, cir[2], nFetch) -> halt

    {0, 0, 0, 0,   0, 0, 0, 0} -> noop_signals
    1 -> accToMdr

    FetchSignals(ring) -> fetch_signals
    HLTSignals(ring) -> halt_signals
    LDASignals(ring) -> lda_signals
    ADDSignals(ring) -> add_signals
    SUBSignals(ring) -> sub_signals
    STASignals(ring) -> sta_signals

    Mux8Way8(noop_signals, lda_signals, add_signals, sub_signals, sta_signals, halt_signals, noop_signals, noop_signals, cir[0..2]) -> cs_candidates
    Mux8(cs_candidates, fetch_signals, isFetch) -> cs

    cs[0] -> loadCir

    cs[1] -> loadMar
    cs[2] -> loadA
    cs[3] -> hbAddr

    cs[4] -> loadB
    cs[5] -> aGetsAluResult
    cs[6] -> negAluY
    cs[7] -> storeA
}

*/

/*
    NOP 0000 XXXX
    LDA 1000 AAAA
    ADD 0100 AAAA
    SUB 1100 AAAA
    STA 0010 AAAA
    HLT 1010 XXXX
*/

/*
module CPU(reset, readData[8]) -> writeData[8], load, addr[4], halt {
    Mux8(pc, operand, hbAddr) -> marInput
    mar: Register(marInput, loadMar) -> addr[0..3]
    Mux8(mdr, alu, aGetsAluResult) -> aInput
    acc: Register(aInput, loadA) -> acc
    acc -> writeData
    mdr: Register(readData, loadB) -> mdr

    Not(hbAddr) -> nhbAddr
    And(loadMar, nhbAddr) -> inc
    pc: PC(reset, inc) -> pc

    ALU(acc, mdr, negAluY) -> alu, carry, zero
    ControlUnit(mdr, reset) -> loadMar, loadA, hbAddr, halt, 
                              loadB, aGetsAluResult, negAluY, load, 
                              operand
}
module Computer(reset) -> halt {
    ram: RAM16(writeData, write, addr) -> readData
    CPU(reset, readData) -> writeData, write, addr, halt
}
*/

module Decoder(ring[6], t0[8], t1[8],  t2[8], t3[8],  t4[8], t5[8]) -> signals[8] {
    Mux8(t0, t1, ring[1]) -> m0
    Mux8(m0, t2, ring[2]) -> m1
    Mux8(m1, t3, ring[3]) -> m2
    Mux8(m2, t4, ring[4]) -> m3
    Mux8(m3, t5, ring[5]) -> signals
}

module FetchSignals() -> t0[8], t1[8], t2[8] {
    {0, 0, 1,   0, 0, 1,   0, 0} -> t0 //load MAR with PC, and increment PC
    {1, 0, 0,   1, 1, 0,   0, 0} -> t1 //load MDR with RAM[MAR]
    {1, 0, 1,   1, 0, 0,   0, 0} -> t2 //load CIR with MDR
}

module NOPSignals(ring[6]) -> signals[8] {
    FetchSignals() -> t0, t1, t2
    {0, 0, 0,   0, 0, 0,   0, 0} -> t3 //NOP
    {0, 0, 0,   0, 0, 0,   0, 0} -> t4 //NOP
    {0, 0, 0,   0, 0, 0,   0, 0} -> t5 //NOP

    Decoder(ring, t0, t1, t2, t3, t4, t5) -> signals
}

module HLTSignals(ring[6]) -> signals[8] {
    FetchSignals() -> t0, t1, t2
    {0, 0, 0,   0, 0, 0,   0, 1} -> t3 //halt
    {0, 0, 0,   0, 0, 0,   0, 1} -> t4 //halt
    {0, 0, 0,   0, 0, 0,   0, 1} -> t5 //halt

    Decoder(ring, t0, t1, t2, t3, t4, t5) -> signals
}

module LDASignals(ring[6]) -> signals[8] {
    FetchSignals() -> t0, t1, t2
    {0, 0, 1,   0, 1, 1,   0, 0} -> t3 //load MAR with LDA operand
    {1, 0, 0,   1, 1, 0,   0, 0} -> t4 //load MDR with RAM[MAR]
    {0, 1, 0,   1, 0, 0,   0, 0} -> t5 //load ACC with MDR

    Decoder(ring, t0, t1, t2, t3, t4, t5) -> signals
}


module ADDSignals(ring[6]) -> signals[8] {
    FetchSignals() -> t0, t1, t2
    {0, 0, 1,   0, 1, 1,   0, 0} -> t3 //load MAR with operand
    {1, 0, 0,   1, 1, 0,   0, 0} -> t4 //load MDR with RAM[MAR]
    {0, 1, 0,   1, 0, 1,   0, 0} -> t5 //load ACC with ACC + MDR

    Decoder(ring, t0, t1, t2, t3, t4, t5) -> signals
}

module SUBSignals(ring[6]) -> signals[8] {
    FetchSignals() -> t0, t1, t2
    {0, 0, 1,   0, 1, 1,   0, 0} -> t3 //load MAR with operand
    {1, 0, 0,   1, 1, 0,   0, 0} -> t4 //load MDR with RAM[MAR]
    {0, 1, 0,   1, 0, 1,   1, 0} -> t5 //load ACC with ACC - MDR

    Decoder(ring, t0, t1, t2, t3, t4, t5) -> signals
}

module STASignals(ring[6]) -> signals[8] {
    FetchSignals() -> t0, t1, t2
    {0, 0, 1,   0, 1, 1,   0, 0} -> t3 //load MAR with operand
    {1, 0, 0,   0, 1, 0,   0, 0} -> t4 //load MDR with ACC
    {1, 1, 0,   1, 0, 0,   0, 0} -> t5 //load RAM[MAR] with MDR

    Decoder(ring, t0, t1, t2, t3, t4, t5) -> signals
}

/*
    dst[3]: null, mdr, acc, mem, mar, cir, null, null
            000   100  010  110  001  101  011   111
    src[3]: null, mdr, acc, mem, pc, alu, operand, null
            000   100  010  110  001 101  011      111
*/
module ControlUnit(cir[8], reset) -> dst[3], src[3], negY, halt {
    ShiftRegister(reset) -> ring

    NOPSignals(ring) -> nop
    LDASignals(ring) -> lda
    HLTSignals(ring) -> hlt
    ADDSignals(ring) -> add
    SUBSignals(ring) -> sub
    STASignals(ring) -> sta

    Mux8Way8(nop, lda, add, sub, sta, hlt, nop, nop, cir[0..2]) -> cs
    {cs[0], cs[1], cs[2]} -> dst
    {cs[3], cs[4], cs[5]} -> src
    cs[6] -> negY
    cs[7] -> halt
}

/*
module CPU(in[8], reset) -> out[8], write, addr[4], halt {
    Mux8Way8(0, mdr, acc, in, pc, alu, operand, 0, src) -> srcData
    DMux8Way(1, dst) -> null0, loadMdr, loadAcc, loadMem, loadMar, loadCir, null6, null7
    mar: Register(srcData, loadMar) -> mar
    mdr: Register(srcData, loadMdr) -> mdr
    acc: Register(srcData, loadAcc) -> acc
    cir: Register(srcData, loadCir) -> cir
    pc: PC(reset, inc) -> pc

    ALU(acc, mdr, negY) -> alu, carry, zero
    ControlUnit(cir, reset) -> dst, src, negY, halt

    //set inc if PC is src
    Not(src[0]) -> ncs3
    Not(src[1]) -> ncs4
    And4Way(1, ncs3, ncs4, src[2]) -> inc

    //read instruction operand
    {cir[4..7], 0, 0, 0, 0} -> operand


    acc -> out
    loadMem -> write
    mar[0..3] -> addr
}
*/

module Computer(reset) -> halt {
    /*
        ram: RAM16(writeData, loadMem, addr) -> readData
        cpu: CPU(readData, reset) -> writeData, memLoad, memAddr, halt
    */

    Mux8Way8(0, mdr, acc, mem, pc, alu, operand, 0, src) -> srcData
    DMux8Way(1, dst) -> null0, loadMdr, loadAcc, loadMem, loadMar, loadCir, null6, null7

    ram: RAM16(acc, loadMem, mar[0..3]) -> mem
    mar: Register(srcData, loadMar) -> mar
    mdr: Register(srcData, loadMdr) -> mdr
    acc: Register(srcData, loadAcc) -> acc
    cir: Register(srcData, loadCir) -> cir
    pc: PC(reset, inc) -> pc

    ALU(acc, mdr, negY) -> alu, carry, zero
    ControlUnit(cir, reset) -> dst, src, negY, halt

    Not(src[0]) -> ncs3
    Not(src[1]) -> ncs4
    And4Way(1, ncs3, ncs4, src[2]) -> inc

    {cir[4..7], 0, 0, 0, 0} -> operand
}

/*
module Computer(reset) -> halt {
    ram: RAM16(acc, storeA, mar[0..3]) -> out

    Mux8(pc, operand, hbAddr) -> marInput
    mar: Register(marInput, loadMar) -> mar
    Mux8(mdr, alu, aGetsAluResult) -> aInput
    acc: Register(aInput, loadA) -> acc
    mdr: Register(out, loadB) -> mdr

    Not(hbAddr) -> nhbAddr
    And(loadMar, nhbAddr) -> inc
    pc: PC(reset, inc) -> pc

    ALU(acc, mdr, negAluY) -> alu, carry, zero
    cu: ControlUnit(mdr, reset) -> loadMar, loadA, hbAddr, accToMdr, 
                              loadB, aGetsAluResult, negAluY, storeA, 
                              operand, halt
}
*/
